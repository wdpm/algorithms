# 平衡二叉树习题

## 提高

### 3.3.31 树的绘制。
为RedBlackBST 添加一个draw() 方法，像正文一样绘制出红黑树。
>TODO

### 3.3.32 AVL 树。
AVL 树是一种二叉查找树，其中任意结点的两棵子树的高度最多相差1（最早的平衡
树算法就是基于使用旋转保持AVL 树中子树高度的平衡）。证明将其中由高度为偶数的结点指
向高度为奇数的结点的链接设为红色就可以得到一棵（完美平衡的）2-3-4 树，其中红色链接可
以是右链接。附加题：使用AVL 树作为数据结构实现符号表的API。一种方法是在每个结点中
保存它的高度并在递归调用后使用旋转来根据需要调整这个高度；另一种方法是在树的表示中
使用红黑链接并使用类似练习3.3.39 和练习3.3.40 的moveRedLeft() 和moveRedRight() 的
方法。
>TODO

### 3.3.33 验证。
为RedBlackBST 实现
- is23() 方法来检查是否存在同时和两条红链接相连的结点,和红色右链接
  - 给定结点Node x，x为null则为true
  - x的右链接为红色，则返回false
  - x不为root，且x的左链接为红，x左链接的左链接也为红，返回false
  - 否则，继续递归x的左右子树。
- isBalanced() 方法来检查从根结点到所有空链接的路径上的黑链接的数量是否相同。
  - 平衡性：黑高相等，表现为从根到叶的所有路径具有相同数量的黑色边。
  - 1.取样：先计算root到最左边叶子结点路径上黑色边的数量int black。
  - 2.递归遍历：给点一个结点Node x，先判断该结点是否为黑，如果是则black--，然后分别递归x的左右子树。x为null则判断black==0
- isBST() 方法检查是否为二叉查找树
  - 对称性：保证二叉查找树的有序性，也称对称顺序。
  - 给点一个结点Node x，这个结点的键为x.key，那么x.left所有键必须 < x.key，x.right的所有键必须 > x.key。以此递归每一个结点。

### 3.3.35 2-3 树。
编写一段程序TwoThreeST.java，使用两种结点类型来直接表示和实现2-3 查找树。
>TODO

### 3.3.37 记忆性。
请证明红黑树不是没有记忆的。例如，如果你向树中插入一个小于所有键的新键，然后立即删除树的最小键，你可能得到一棵不同的树。
>TODO

## 实验题
>TODO

### 3.3.42 统计红色结点。
编写一段程序，统计给定的红黑树中红色结点所占的比例。对于N=10^4、10^5 和10^6，用你的程序统计至少100 棵随机构造的大小为N 的红黑树并得出一个猜想。

### 3.3.43 成本图。
改造RedBlackBST 的实现来绘制本节中能够显示计算中每次put() 操作的成本的图（请
参考练习3.1.38）。

### 3.3.44 平均查找用时。
用实验研究和计算在一棵由N 个随机结点构造的红黑树中到达一个随机结点的
平均路径长度（内部路径长度除以N 再加1）的平均差和标准差，对于1 到10 000 之间的每个
N 至少重复实验1000 遍。将结果绘制成和图3.3.30 相似的Tufte 图，并画上函数lgN-0.5 的曲线。

### 3.3.45 统计旋转。
改进你为练习3.3.43 给出的程序，用图像绘制出在构造红黑树的过程中旋转和分解结点的次数并讨论结果。

### 3.3.46 红黑树的高度。
改进你为练习3.3.43 给出的程序，用图像绘制出所有红黑树的高度并讨论结果。